import{getType,isType}from"@yomua/y-screw";import log from"@yomua/y-tlog";function flag(e,r,t){const s=e.__flags||(e.__flags=Object.create(null));if(3!==arguments.length)return s[r];s[r]=t}class AssertMessage{constructor(){this._error=null}set error(e){this._error=e}get error(){return this._error}}var enUS={"expect.equal.unknown.error":"Unknown error","expect.equal.value.error":"Value mismatch","expect.equal.type.error":"Type mismatch","expect.equal.array.length.error":"Array length mismatch","expect.equal.array.item.error":"Array item mismatch","expect.equal.object.value.error":"Object value mismatch","expect.equal.object.key.error":"Object key mismatch","expect.equal.object.key.length.error":"Object key length mismatch"},zhCN={"expect.equal.unknown.error":"未知错误","expect.equal.value.error":"值不匹配","expect.equal.type.error":"类型不匹配","expect.equal.array.length.error":"数组长度不匹配","expect.equal.array.item.error":"数组项不匹配","expect.equal.object.value.error":"对象值不匹配","expect.equal.object.key.error":"对象键不匹配","expect.equal.object.key.length.error":"对象键长度不匹配"};function isPrimitive(e){return"object"!=typeof e&&null!==e}function getLocales(){switch(assert.locales){case"zh-CN":default:return zhCN;case"en-US":return enUS}}function getExpectInstance(){return ExpectClass._getInstance()}const canElideFrames="captureStackTrace"in Error,{dye:dye$1}=log;class AssertError extends Error{get name(){return dye$1.error("AssertError")}constructor(e="Unspecified AssertError",r={},t=AssertError){super(e),canElideFrames&&Error.captureStackTrace(this,t);for(const e in r)e in this||(this[e]=r[e])}toOriginal(e){return Object.assign(Object.assign({},this),{name:this.name,message:this.message,stack:!1!==e?this.stack:void 0})}}const{dye:dye}=log;function getErrorMessage(e,r=""){const t=getLocales();return dye.bgRgb(255,0,0)(t[e]+r)}function throwError(e){throw new AssertError(e)}const EXPECT_KEY="expect",message=new AssertMessage;function equal(e){var r,t,s,a,o,n;const c=getExpectInstance(),l=flag(c,"expect");if(getType(l)!==getType(e)&&throwError(null!==(r=message.error)&&void 0!==r?r:getErrorMessage("expect.equal.type.error",`: ${getType(l)} !== ${getType(e)}`)),isType(l,"array")&&isType(e,"array")){const r=l.length,a=e.length;r!==a&&(message.error=getErrorMessage("expect.equal.array.length.error",`: ${r} !== ${a}`),throwError(message.error));for(let a=0;a<r;a++){const r=e[a],o=l[a];message.error=getErrorMessage("expect.equal.array.item.error",`: ${null!==(t=null==o?void 0:o.toString())&&void 0!==t?t:o} !== ${null!==(s=null==r?void 0:r.toString())&&void 0!==s?s:r}`),flag(c,"expect",o),equal(r)}return!0}if(isType(l,"object")&&isType(e,"object")){const r=Reflect.ownKeys(l),t=Reflect.ownKeys(e);r.length!==t.length&&(message.error=getErrorMessage("expect.equal.object.key.length.error",`: ${r.length} !== ${t.length}`),throwError(message.error));for(let s=0;s<r.length;s++){const n=r[s],i=t[s];Object.is(n,i)||(message.error=getErrorMessage("expect.equal.object.key.error",`: ${null!==(a=null==n?void 0:n.toString())&&void 0!==a?a:n} !== ${null!==(o=null==i?void 0:i.toString())&&void 0!==o?o:i}`),throwError(message.error));const u=l[n],g=e[i];message.error=getErrorMessage("expect.equal.object.value.error",`: ${u} 不等于 ${g}`),flag(c,"expect",u),equal(g)}return!0}return!(!isType(l,"null")||!isType(e,"null"))||(isPrimitive(l)&&isPrimitive(e)?(Object.is(l,e)||throwError(null!==(n=message.error)&&void 0!==n?n:getErrorMessage("expect.equal.value.error",`: ${String(l)} !== ${String(e)}`)),!0):void throwError(getErrorMessage("expect.equal.unknown.error",`: source: ${l}, target: ${e}`)))}class ExpectClass{constructor(e){return ExpectClass._instance?(flag(ExpectClass._instance,"expect",e),ExpectClass._instance):(flag(this,"expect",e),ExpectClass._instance=this,ExpectClass._instance)}static _getInstance(){if(ExpectClass._instance)return ExpectClass._instance;throw new Error("ExpectClass 需要先 new, 再调用 ExpectClass._getInstance()")}equal(e){return equal(e)}}const expect=e=>new ExpectClass(e),assert=()=>{};assert.expect=expect,assert.locales="zh-CN";export{assert as default};
